{"version":3,"sources":["webpack://flat-js-next/./web/components/monaco.vue","webpack://flat-js-next/./web/components/debugger-value.vue","webpack://flat-js-next/./web/components/debugger.vue","webpack://flat-js-next/./web/index.vue"],"names":[],"mappings":";AAkGA;IACA;IACA;IACA;AACA;AAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;;;ACiCA;IACA;AACA;AACA;IACA;AACA;AAEA;IACA;AACA;AAEA;IACA;AACA;AAEA;IACA;AACA;AAEA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;AACA;;;AC/GA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;AACA;;;ACuYA;;IAEA;IACA;IACA;AACA;AAEA;IACA;AACA;AACA;IACA;AACA;;;AAGA;IACA;IACA;IACA;IACA;2BACA;IACA;AACA;AACA;IACA;iCACA;IACA;IACA;AACA;AACA;IACA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;IACA;IACA;AACA;AACA;IACA;IACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;IACA;AACA;AAEA;IACA;IACA;IACA;IACA;AACA;AACA;IACA;IACA;IACA;AACA;AACA;IACA;IACA;IACA;AACA;AACA;IACA;AACA;AACA;IACA;IACA;IACA;IACA;AACA;AACA;IACA;IACA;AACA;AACA;IACA;IACA;AACA;AACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;AACA;AACA;IACA;AACA","file":"main.css","sourcesContent":["<template>\n    <div ref=\"editor\"></div>\n</template>\n\n<script lang=\"ts\">\nimport * as monaco from 'monaco-editor';\nimport Vue from 'vue'\nfunction withNonReactive<TData>(data: TData) {\n    return <TNonReactive>() => data as TData & TNonReactive;\n}\n\nexport default Vue.extend({\n    props: {\n        value: {\n            type: String,\n            default: ''\n        },\n        readonly: {\n            type: Boolean,\n            default: false\n        },\n        highlights: {\n            type: Array as () => [number, number, number, number][],\n            default () {\n                return []\n            }\n        }\n    },\n    data () {\n        return withNonReactive({})<{\n            editor: monaco.editor.IStandaloneCodeEditor,\n            currentDecorations: string[]\n        }>()\n    },\n    computed: {\n        highlightSerialized (): string {\n            return JSON.stringify(this.highlights)\n        }\n    },\n    watch: {\n        value (newVal) {\n            const editor = this .editor\n            const current = editor.getValue()\n            if (current !== newVal) {\n                editor.setValue(newVal)\n            }\n        },\n        readonly (newVal) {\n            this.editor.updateOptions({\n                readOnly: newVal\n            })\n        },\n        highlightSerialized () {\n            this.currentDecorations = this.editor.deltaDecorations(\n                this.currentDecorations,\n                this.highlights.map(([r1, c1, r2, c2]) => ({\n                    range: new monaco.Range(r1, c1, r2, c2), \n                    options: { inlineClassName: 'inline-highlight' }\n                }))\n            )\n        }\n    },\n    mounted () {\n        this.currentDecorations = []\n        const editor = this.editor = monaco.editor.create(this.$refs.editor as any, {\n            value: this.value,\n            language: 'javascript',\n            scrollBeyondLastLine: false,\n            automaticLayout: true\n        });\n\n        editor.onDidChangeModelContent(ev => {\n            const value = editor.getValue()\n            if (value !== this.value) {\n                this.$emit('input', editor.getValue())\n            }\n        })\n\n        if (this.readonly) {\n            this.editor.updateOptions({\n                readOnly: true\n            })\n        }\n\n        if (this.highlights.length > 0) {\n            this.currentDecorations = this.editor.deltaDecorations(\n                this.currentDecorations,\n                this.highlights.map(([r1, c1, r2, c2]) => ({\n                    range: new monaco.Range(r1, c1, r2, c2), \n                    options: { inlineClassName: 'inline-highlight' }\n                }))\n            )\n        }\n    }\n})\n</script>\n\n<style scoped>\n::v-deep .inline-highlight {\n    position: relative;\n    background: rgb(251, 255, 0);\n    outline: 1px solid rgba(255, 0, 0, 0.3);\n}\n\n::v-deep .inline-highlight ~ .inline-highlight::before{\n    position: absolute;\n    display: block;\n    content: \"\";\n    left: -1px;\n    top: 0.5px;\n    bottom: 0.5px;\n    width: 2px;\n    background: rgb(251, 255, 0);\n}\n</style>","<template>\n    <div class=\"debugger-value\">\n        <span v-if=\"displayKey !== null\">{{ displayKey }}:</span>\n        <span v-if=\"type === 'error'\" class=\"error\">{{serialized}}</span>\n        <span v-if=\"type === 'number'\" class=\"number\">{{serialized}}</span>\n        <span v-if=\"type === 'string'\" class=\"string\">{{serialized}}</span>\n        <span v-if=\"type === 'boolean'\" class=\"boolean\">{{serialized}}</span>\n        <span v-if=\"type === 'null'\" class=\"null\">{{serialized}}</span>\n        <span v-if=\"type === 'undefined'\" class=\"undefined\">{{serialized}}</span>\n        <span v-if=\"type === 'object'\" class=\"object\" @click=\"expand = !expand\">\n            {{serialized}} {{ expand ? '[-] Collapse' : '[+] Expand' }}\n        </span>\n        <span v-if=\"type === 'function'\" class=\"function\" @click=\"expand = !expand\">\n            {{serialized}} {{ expand ? '[-] Collapse' : '[+] Expand' }}\n        </span>\n        <div v-if=\"expand\" class=\"properties\">\n            <div v-for=\"entry of childEntries\" :key=\"JSON.stringify([entry[0], entry[1]])\" :key1=\"JSON.stringify([entry[0], entry[1]])\">\n                <debugger-value :isError=\"entry[0] === EntryType.stringKeyError || entry[0] === EntryType.symbolKeyError\" :refreshKey=\"refreshKey\" :displayKey=\"entry[1]\" :value=\"entry[2]\" />\n            </div>\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\n\nenum EntryType {\n    stringKeyProp,\n    stringKeyGetSet,\n    stringKeyError,\n    symbolKeyProp,\n    symbolKeyGetSet,\n    symbolKeyError,\n    prototype\n}\n\nexport default Vue.extend({\n    name: 'DebuggerValue',\n    props: {\n        initialExpand: {\n            type: Boolean,\n            default: false\n        },\n        isError: {\n            type: Boolean,\n            default: false\n        },\n        displayKey: {\n            type: String,\n            default: null\n        },\n        forcedProp: {\n            type: Boolean,\n            default: false\n        },\n        refreshKey: {\n            type: Number,\n            default: 0\n        },\n        value: {}\n    },\n    data () {\n        return {\n            expand: this.initialExpand,\n            EntryType\n        }\n    },\n    computed: {\n        type (): string {\n            this.refreshKey\n            return this.isError ? 'error' : this.value === null ? 'null' : typeof this.value\n        },\n        serialized (): string {\n            this.refreshKey\n            if (this.isError) return String(this.value)\n            if (this.value === undefined) return 'undefined'\n            if (this.value === null) return 'null'\n            if (typeof this.value === 'object') return 'Object {}'\n            if (typeof this.value === 'function') return 'function'\n            if (typeof this.value === 'number') return String(this.value)\n            return JSON.stringify(this.value)\n        },\n        childEntries (): [EntryType, string | symbol, unknown | PropertyDescriptor][] {\n            this.refreshKey\n            if (this.type !== 'object' && this.type !== 'function') {\n                return []\n            }\n\n            const keys = Reflect.ownKeys(this.value as any)\n\n            const entries: [EntryType, string | symbol, unknown | PropertyDescriptor][] = []\n\n            for (let key of keys) {\n                const desc = Reflect.getOwnPropertyDescriptor(this.value as any, key)!\n                if (typeof key === 'string') {\n                    try {\n                        if ('value' in desc || this.forcedProp) {\n                            entries.push([EntryType.stringKeyProp, this.wrapIdentifier(key), (this.value as any)[key]])\n                        } else {\n                            entries.push([EntryType.stringKeyGetSet, 'get/set ' + this.wrapIdentifier(key), desc])\n                        }\n                    } catch (err) {\n                        if ('value' in desc || this.forcedProp) {\n                            entries.push([EntryType.stringKeyError, this.wrapIdentifier(key), String(err)])\n                        } else {\n                            entries.push([EntryType.stringKeyError, 'get/set ' + this.wrapIdentifier(key), String(err)])\n                        }\n                    }\n                } else {\n                    try {\n                        if ('value' in desc || this.forcedProp) {\n                            entries.push([EntryType.symbolKeyProp, this.wrapIdentifier(key.toString()), (this.value as any)[key]])\n                        } else {\n                            entries.push([EntryType.stringKeyGetSet, 'get/set ' + this.wrapIdentifier(key.toString()), desc])\n                        }\n                    } catch (err) {\n                        if ('value' in desc || this.forcedProp) {\n                            entries.push([EntryType.symbolKeyError, this.wrapIdentifier(key.toString()), String(err)])\n                        } else {\n                            entries.push([EntryType.symbolKeyError, 'get/set ' + this.wrapIdentifier(key.toString()), String(err)])\n                        }\n                    }\n                }\n            }\n\n            const proto = Reflect.getPrototypeOf(this.value as any)\n            if (proto != null) {\n                entries.push([EntryType.prototype, '[[prototype]]', proto])\n            }\n\n            return entries\n        }\n    },\n    methods: {\n        wrapIdentifier (str: string) {\n            if (!/[\"'\\(\\)\\r\\n]/.test(str)) {\n                return str\n            }\n\n            return JSON.stringify(str)\n        }\n    }\n})\n</script>\n\n<style scoped>\n.debugger-value {\n    font-family: monospace;\n}\n.properties {\n    margin-left: 1em;\n}\n\n.error {\n    color: #ff0000;\n}\n\n.number {\n    color: #ff4800;\n}\n\n.boolean {\n    color: #64a100;\n}\n\n.null {\n    color: #76a100;\n}\n.undefined {\n    color: #a1001b;\n}\n.string {\n    color: #d400ff;\n}\n.object {\n    color: #36c000;\n}\n.function {\n    color: #4e5cd6;\n}\n</style>","<template>\n    <div>\n        <div class=\"header\">\n            Scopes\n        </div>\n        <div class=\"area\">\n            <div v-for=\"scope in scopes\" :key=\"getKey(scope)\" :key1=\"getKey(scope)\">\n                <debuggerValue displayKey=\"Scope\" :initialExpand=\"!isGlobalThis(scope)\" :refreshKey=\"refreshKey + refreshKeyInternal\" :value=\"scope\" :forcedProp=\"true\"/>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport Vue from 'vue'\nimport { Fields, Scope, Stack } from '../../src/runtime'\nimport DebuggerValue from './debugger-value.vue'\n\nlet id = 0\nlet map = new WeakMap<any, number>()\n\nconst getKey = (obj: any) => {\n    if (!map.has(obj)) {\n        const newId = id++\n        map.set(obj, newId)\n    }\n\n    return map.get(obj)!\n}\n\nexport default Vue.extend({\n    components: {\n        DebuggerValue\n    },\n    props: {\n        stackContainer: {\n            type: Object as () => { stack: Stack },\n            default (): { stack: Stack } {\n                return { stack: [] }\n            }\n        },\n        refreshKey: {\n            type: Number,\n            default: 0\n        }\n    },\n    data () {\n        return {\n            refreshKeyInternal: Math.random()\n        }\n    },\n    computed: {\n        scopes (): Scope[] {\n            const stack = this.stackContainer.stack\n            const top = stack[stack.length - 1]\n            return top ? top[Fields.scopes].slice(0).reverse() : []\n        }\n    },\n    methods: {\n        getKey,\n        isGlobalThis (v: any) {\n            return v === globalThis\n        }\n    }\n})\n</script>\n\n<style scoped>\n.header {\n    padding: 0.5em 1em;\n}\n.area {\n    padding: 0 1em;\n}\n.header, .area {\n    border-bottom: 1px solid rgba(127, 127, 127, 0.5);\n}\n</style>","<template>\n    <div class=\"app\" :class=\"{ running: state !== 'idle' }\">\n        <div v-show=\"state !== 'idle'\" class=\"area-debug pane\">\n            <div class=\"pane-title\">\n                debug\n            </div>\n            <div class=\"pane-content\">\n                <debugger :refreshKey=\"refreshKey\" :stack-container=\"stackContainer\" />\n            </div>\n        </div>\n        <div class=\"area-code pane\">\n            <div class=\"pane-title\">\n                Code\n            </div>\n            <monaco\n                class=\"pane-content\"\n                v-model=\"text\"\n                :readonly=\"state !== 'idle'\"\n                :highlights=\"highlights\"\n            ></monaco>\n            <div class=\"pane-footer\">\n                <button v-if=\"state === 'idle'\" class=\"run-button\" @click=\"run\">Run</button>\n                <button v-if=\"state === 'idle'\" class=\"run-button\" @click=\"runAndPause\">Run and pause</button>\n                <button v-if=\"state === 'paused'\" class=\"run-button\" @click=\"resume\">Resume</button>\n                <button v-if=\"state === 'paused'\" class=\"run-button\" @click=\"stepExecution(false)\">Step</button>\n                <button v-if=\"state === 'paused'\" class=\"run-button\" @click=\"stepExecution(true)\">Step in</button>\n                <button v-if=\"state === 'paused'\" class=\"run-button\" @click=\"stop\">Kill</button>\n                <button v-if=\"state === 'play'\" class=\"run-button\" @click=\"pause\">Pause</button>\n                <button v-if=\"state === 'play'\" class=\"run-button\" @click=\"stop\">Kill</button>\n            </div>\n        </div>\n        <div class=\"area-result pane\">\n            <div class=\"pane-title\">\n                Result\n            </div>\n            <div ref=\"result\" class=\"result-pane pane-content\">\n                <pre class=\"result\">{{ result }}</pre>\n            </div>\n            <input\n                v-if=\"state === 'paused'\"\n                class=\"pane-footer repl\"\n                v-model=\"replText\"\n                @keydown.enter=\"runRepl\"\n                type=\"text\"\n                placeholder=\"Code here...\"\n            >\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { compile, getExecution, run } from '../src'\nimport Vue from 'vue'\nimport Monaco from './components/monaco.vue'\nimport Debugger from './components/debugger.vue'\nimport { FrameType, Result, Stack } from '../src/runtime'\nimport { Fields } from '../src/runtime'\nimport { DebugInfo } from '../src/compiler'\n\ntype State = 'play' | 'paused' | 'idle'\n\nfunction withNonReactive<TData>(data: TData) {\n    return <TNonReactive>() => data as TData & TNonReactive;\n}\n\nfunction makeGlobalThis() {\n    const names = [\n        'Infinity',\n        'NaN',\n        'undefined',\n        'Math',\n        \n        'isFinite',\n        'isNaN',\n        'parseFloat',\n        'parseInt',\n        'decodeURI',\n        'decodeURIComponent',\n        'encodeURI',\n        'encodeURIComponent',\n        'Array',\n        'ArrayBuffer',\n        'Boolean',\n        'DataView',\n        'Date', \n        'Error',\n        'EvalError',\n        'Float32Array',\n        'Float64Array',\n        'Function',\n\n\n        'Int8Array',\n        'Int16Array',\n        'Int32Array',\n\n        'Map',\n        'Number',\n        'Object',\n        'Promise',\n        'Proxy',\n        'RangeError',\n        'ReferenceError',\n        'RegExp',\n        'Set',\n        'SharedArrayBuffer',\n        'String',\n        'Symbol',\n        'SyntaxError',\n        'TypeError',\n\n        'Uint8Array',\n        'Uint8ClampedArray',\n        'Uint16Array',\n        'Uint32Array',\n\n        'URIError',\n        'WeakMap',\n        'WeakSet',\n    \n        'Atomics',\n        'JSON',\n        'Reflect',\n    \n        'escape',\n        'unescape',\n    \n        'Intl',\n\n        'eval'\n    ]\n\n    const obj: any = {}\n\n    for (let name of names) {\n        if (Reflect.has(globalThis, name)) {\n            obj[name] = (globalThis as any)[name]\n        }\n    }\n\n    Reflect.defineProperty(obj, 'globalThis', {\n        enumerable: true,\n        configurable: false,\n        value: obj\n    })\n\n    return obj\n}\n\nconst fakeGlobalThis = makeGlobalThis()\n\nexport default Vue.extend({\n    components: {\n        Monaco,\n        Debugger\n    },\n    data() {\n        return withNonReactive({\n            text: `clear()\nconst start = Date.now()\nlet a = 0\n\nconst fn = (b) => {\n  print(b)\n}\n\nprint(eval('a'))\n\nfor (let i = 0; i < 5; i++) {\n  a = a + 1\n  fn(a)\n}\n\nprint(a)\n\ndo {\n  try {\n    print(1)\n    throw new Error('')\n  } finally {\n    break\n  }\n} while (false)\n\nObject.defineProperty(Object.prototype, '__magic__', {\n\tget: function() {\n\t\treturn this;\n\t},\n\tconfigurable: true\n});\nprint(Object.keys(__magic__));\ndelete Object.prototype.__magic__;\n\ndebugger\nprint('total time: ' + (Date.now() - start) + 'ms')\n\n`,\n            result: '',\n            replText: '',\n            stackContainer: {\n                stack: [] as Stack\n            },\n            state: 'idle' as State,\n            refreshKey: Math.random(),\n            debugInfo: <DebugInfo>{ sourceMap: [], internals: [] },\n            highlights: <[number, number, number, number][]>[]\n        })<{\n            execution: ReturnType<typeof getExecution>,\n            program: number[]\n        }>()\n    },\n    watch: {\n        async result () {\n            const container = this.$refs.result as HTMLDivElement\n            await this.$nextTick()\n            if (container.scrollHeight - container.offsetHeight > container.scrollTop) {\n                container.scrollTop = container.scrollHeight - container.offsetHeight\n            }\n        }\n    },\n    methods: {\n        printError(err: any) {\n            this.result += String(err) + '\\n'\n            if (err != null && typeof err === 'object') {\n                if ('stack' in err) {\n                    this.result += err.stack + '\\n'\n                }\n            }\n        },\n        stepExecution(stepIn = false) {\n            const execution = this.execution\n\n            let stack = execution[Fields.stack]\n            this.stackContainer = {\n                get stack () {\n                    return stack\n                }\n            }\n\n            let result: Result\n\n            try {\n                const getPos = () => {\n                    const currentPosition = execution[Fields.ptr]\n                    return this.debugInfo.sourceMap[currentPosition]\n                }\n\n                const originalPos = getPos().join(',')\n                const getCurrentStackLength = () => execution[Fields.stack].filter(it => it[Fields.type] === FrameType.Function).length\n                let maxStack = getCurrentStackLength()\n                let skipping = false\n                let firstIgnored = false\n\n                do {\n                    result = execution[Fields.step](true)\n\n                    if (!skipping) {\n                        skipping = stepIn ? false : getCurrentStackLength() > maxStack\n                    } else /** if (skipping) */ {\n                        if (!firstIgnored && getCurrentStackLength() <= maxStack) {\n                            firstIgnored = true\n                        } else if (firstIgnored) {\n                            firstIgnored = false\n                            skipping = false\n                        }\n                    }\n\n                    maxStack = Math.min(maxStack, getCurrentStackLength())\n                } while (\n                    (\n                        getPos().join(',') === originalPos ||\n                        this.debugInfo.internals[execution[Fields.ptr]] ||\n                        skipping\n                    )\n                    && !result.done\n                )\n\n                this.refreshKey = Math.random()\n\n                const [r1, c1, r2, c2] = getPos()\n                this.highlights = [[r1 + 1, c1 + 1, r2 + 1, c2 + 1]]\n                \n                if (result.done) {\n                    this.state = 'idle'\n                }\n                if (this.state === 'idle') {\n                    this.highlights = []\n                }\n\n            } catch (err) {\n                this.printError(err)\n                this.state = 'idle'\n                this.highlights = []\n            }\n        },\n        async runExecution() {\n            this.state = 'play'\n            const execution = this.execution\n\n            let stack = this.execution[Fields.stack]\n            this.stackContainer = {\n                get stack () {\n                    return stack\n                }\n            }\n\n            let result: Result\n\n            const getPos = () => {\n                const currentPosition = execution[Fields.ptr]\n                return this.debugInfo.sourceMap[currentPosition]\n            }\n\n            let prevPos = getPos().join('')\n\n            try {\n                do {\n                    result = execution[Fields.step](true)\n\n                    if (getPos().join('') !== prevPos && !this.debugInfo.internals[execution[Fields.ptr]]) {\n                        let stack = execution[Fields.stack]\n                        this.stackContainer = {\n                            get stack () {\n                                return stack\n                            }\n                        }\n                        this.refreshKey = Math.random()\n\n                        const [r1, c1, r2, c2] = getPos()\n                        this.highlights = [[r1 + 1, c1 + 1, r2 + 1, c2 + 1]]\n\n                        await new Promise(r => setTimeout(r, 200))\n                    }\n\n                    prevPos = getPos().join('')\n                } while (this.state === 'play' && !result.done)\n\n                if (<State>this.state === 'paused') {\n                    const [r1, c1, r2, c2] = getPos()\n                    this.highlights = [[r1 + 1, c1 + 1, r2 + 1, c2 + 1]]\n                }\n\n                if (result.done) {\n                    this.state = 'idle'\n                }\n                if (this.state === 'idle') {\n                    this.highlights = []\n                }\n\n            } catch (err) {\n                this.printError(err)\n                this.state = 'idle'\n                this.highlights = []\n            }\n        },\n        run() {\n            const clear = (val: any) => {\n                this.result = ''\n            }\n\n            const print = (val: any) => {\n                this.result += JSON.stringify(val, undefined, 2) + '\\n'\n            }\n\n            let programData: number[], textData: any[], debugInfo: DebugInfo\n            try {\n                [programData, textData, debugInfo] = compile(this.text, { range: true })\n            } catch (err) {\n                this.printError(err)\n                return\n            }\n\n\n            this.debugInfo = debugInfo\n            this.program = programData\n            this.execution = getExecution(\n                programData,\n                textData,\n                0,\n                fakeGlobalThis,\n                [{ print, clear, __proto__: null }],\n                undefined,\n                [],\n                () => () => this.pause(),\n                compile\n            )\n\n            this.runExecution()\n        },\n        runAndPause() {\n            const clear = (val: any) => {\n                this.result = ''\n            }\n\n            const print = (val: any) => {\n                this.result += JSON.stringify(val, undefined, 2) + '\\n'\n            }\n\n            let programData: number[], textData: any[], debugInfo: DebugInfo\n            try {\n                [programData, textData, debugInfo] = compile(this.text, { range: true })\n            } catch (err) {\n                this.printError(err)\n                return\n            }\n\n            this.debugInfo = debugInfo\n            this.program = programData\n            this.execution = getExecution(\n                programData,\n                textData,\n                0,\n                fakeGlobalThis,\n                [{ print, clear, __proto__: null }],\n                undefined,\n                [],\n                () => () => this.pause(),\n                compile\n            )\n\n            this.pause()\n        },\n        pause() {\n            this.state = 'paused'\n            // force non reactive\n            let stack = this.execution[Fields.stack]\n            this.stackContainer = {\n                get stack () {\n                    return stack\n                }\n            }\n            this.refreshKey = Math.random()\n        },\n        resume() {\n            this.runExecution()\n        },\n        stop() {\n            this.highlights = []\n            this.state = 'idle'\n        },\n        runRepl() {\n            const text = this.replText\n            this.replText = ''\n\n            let programData: number[], textData: any[]\n\n            this.result += '> ' + text + '\\n'\n\n            try {\n                [programData, textData] = compile(text, { evalMode: true })\n            } catch (err) {\n                this.printError(err)\n                return\n            }\n\n            try {\n                const result = run(programData, textData, 0, fakeGlobalThis, [...this.execution[Fields.scopes]])\n                this.result += result + '\\n'\n            } catch (err) {\n                this.printError(err)\n            }\n        }\n    }\n})\n</script>\n\n<style>\nbody,\nhtml {\n    background: black;\n    margin: 0;\n    padding: 0;\n}\n\nbody {\n    color: #eee;\n}\npre {\n    margin: 0;\n}\n</style>\n<style scoped>\n.app {\n    height: 100vh;\n    width: 100vw;\n    display: grid;\n    grid-template-areas: \"code\"\n                   \"result\";\n    grid-template-rows: 1fr 1fr;\n}\n.app.running {\n    grid-template-areas: \"debug code\"\n                   \"debug result\";\n    grid-template-rows: 1fr 1fr;\n    grid-template-columns: 400px 1fr;\n}\n.area-debug {\n    grid-area: debug;\n    border-right: 1px solid rgba(127, 127, 127, 0.5);\n}\n.area-debug .pane-content {\n    overflow-y: auto;\n}\n.area-code {\n    grid-area: code;\n}\n.area-code .pane-footer {\n    display: flex;\n    align-items: stretch;\n    justify-content: stretch;\n}\n.area-code .pane-footer > * {\n    flex: 1 1 0;\n    position: relative;\n}\n.area-code .pane-footer > *:not(:first-child)::before {\n    content: \"\";\n    position: absolute;\n    left: 0;\n    top: 0;\n    bottom: 0;\n    width: 1px;\n    background: rgba(255, 255, 255, 0.5);\n}\n.area-result {\n    grid-area: result;\n}\n\n.pane {\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n    overflow: clip;\n}\n.pane-title {\n    padding: 1em;\n    flex-grow: 0;\n    border-bottom: 1px solid rgba(127, 127, 127, 0.5);\n}\n.pane-content {\n    flex-grow: 1;\n    overflow: hidden;\n    overflow: clip;\n}\n.pane-footer {\n    flex-grow: 0;\n}\n.run-button {\n    border: 0;\n    background: #777;\n    padding: 1em;\n    color: white;\n}\n.result-pane {\n    overflow-y: auto;\n    position: relative;\n}\n.result {\n    padding: 1em;\n    line-height: 2em;\n}\n.repl {\n    width: 100%;\n    width: available;\n    border: 0;\n    padding: 1em;\n    outline: 0;\n    background: #333;\n    color: white;\n}\n.repl::placeholder {\n    color: #777;\n}\n</style>"],"sourceRoot":""}